\documentclass[article,nojss]{jss}
\DeclareGraphicsExtensions{.pdf,.eps}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Add-on packages and fonts
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{float}


\newcommand{\noun}[1]{\textsc{#1}}
%% Bold symbol macro for standard LaTeX users
\providecommand{\boldsymbol}[1]{\mbox{\boldmath $#1$}}

%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\newcommand{\fme}{\textbf{\textsf{FME }}}
\newcommand{\ds}{\textbf{\textsf{deSolve }}}
\newcommand{\rs}{\textbf{\textsf{rootSolve }}}
\newcommand{\R}{\proglang{R}}
\title{\proglang{R}-package \fme: tests}
\Plaintitle{FME-tests}

\Keywords{simulation models, differential equations, fitting, sensitivity,
monte carlo, identifiability  \proglang{R}}

\Plainkeywords{simulation models, differential equations, fitting, sensitivity, monte carlo, identifiability, R}


\author{Karline Soetaert\\
NIOO-CEME\\
The Netherlands
}

\Plainauthor{Karline Soetaert}

\Abstract{This vignette tests several applications of \R package \fme.}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Karline Soetaert\\
  Centre for Estuarine and Marine Ecology (CEME)\\
  Netherlands Institute of Ecology (NIOO)\\
  4401 NT Yerseke, Netherlands\\
  E-mail: \email{k.soetaert@nioo.knaw.nl}\\
  URL: \url{http://www.nioo.knaw.nl/ppages/ksoetaert}\\
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% R/Sweave specific LaTeX commands.
%% need no \usepackage{Sweave}
%\VignetteIndexEntry{FME - utilities for the application of models consisting of differential equations}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Begin of the document
\begin{document}
\SweaveOpts{engine=R,eps=FALSE}
\SweaveOpts{keep.source=TRUE}

<<preliminaries,echo=FALSE,results=hide>>=
library("FME")
options(prompt = "> ")
options(width=70)
@

\maketitle

\section{Introduction}
Here three applications from \R-package \fme are tested.

\begin{itemize}
\item Three tests of the implemented MCMC method:
\begin{itemize}
\item The "banana" function, a curvilnear function
\item A monod function, fitted to a data-series
\item A simple chemical model, fitted to a data series
\end{itemize}
\item sensitivity analysis, fitting, MCMC, ... of a simple model of sedimentary
oxygen
\end{itemize}

\section{The banana}

A banana-shaped function.

This example is from Haario et al. 2005

First two banana functions are defined, taking as input a vector or a matrix
<<>>=
Banana <- function (x, a=1, b=1)
{
  y1<-x[1]*a
  y2<-x[2]/a -b*(y1^2+a^2)

  return(c(y1,y2))
}

# banana matix function
BananaM <- function (X, a=1, b=1)
{

  y1<-X[,1]*a
  y2<-X[,2]/a -b*(y1^2+a^2)

  return(cbind(y1,y2))
}
@
We also need a function that estimates the probability of a multinormally
distributed vector
<<>>=
pmultinorm <- function(value,mean,Cov)

{
 diff <- value - mean
 ex   <- -0.5*t(diff) %*% solve(Cov) %*% diff

 rdet   <- sqrt(det(Cov))

  power  <- -length(diff)*0.5
  return((2.*pi)^power / rdet * exp(ex))
}
@

The target function returns -2 *log (probability) of the value
<<>>=
BananaSS <- function (p)
{
  P <- Banana(p)
  Cov <- matrix(nr=2,data=c(1,0.9,0.9,1))
 -2*sum(log(pmultinorm(P,mean=0,Cov=Cov)))
}
@

First Markov chain is generated with simple metropolis hastings algorithm
<<>>=
MCMC <- modMCMC(f=BananaSS, p=c(0,0.5), jump=diag(nrow=2,x=5),
                niter=1000)
@
Next we use the adaptive metropolis - update proposal every 100 runs
<<>>=
MCMC2 <- modMCMC(f=BananaSS, p=c(0,0.5), jump=diag(nrow=2,x=5),
                 updatecov=100,niter=1000)
@
and the metropolis with delayed rejection
<<>>=
MCMC3 <- modMCMC(f=BananaSS, p=c(0,0.5), jump=diag(nrow=2,x=5),
                 ntrydr=2,niter=1000)
@

Finally the adaptive metropolis with delayed rejection
<<>>=
print(system.time(
MCMC4 <- modMCMC(f=BananaSS, p=c(0,0.5), jump=diag(nrow=2,x=5),
                 updatecov=100,ntrydr=2,niter=1000)
))
@
Plot the generated values
<<label=banana, include=FALSE>>=
par(mfrow=c(4,2))
par(mar=c(2,2,4,2))
plot(MCMC,mfrow=NULL,main="MH")
plot(MCMC2,mfrow=NULL,main="AM")
plot(MCMC3,mfrow=NULL,main="DR")
plot(MCMC4,mfrow=NULL,main="DRAM")
par(mar=c(5.1,4.1,4.1,2.1))
@
\setkeys{Gin}{width=1.0\textwidth}
\begin{figure}
\begin{center}
<<label=banana,fig=TRUE,echo=FALSE>>=
<<banana>>
@
\end{center}
\caption{The MCMC results - see text for \R-code}
\label{fig:ba}
\end{figure}

and the parameter combinations
<<label=banana2, include=FALSE>>=
par(mfrow=c(2,2))
plot(MCMC$pars,main="MH")
plot(MCMC2$pars,main="AM")
plot(MCMC3$pars,main="DR")
plot(MCMC4$pars,main="DRAM")
@
\setkeys{Gin}{width=0.6\textwidth}
\begin{figure}
\begin{center}
<<label=banana2,fig=TRUE,echo=FALSE>>=
<<banana2>>
@
\end{center}
\caption{The bananas - see text for \R-code}
\label{fig:bana}
\end{figure}

Estimate summaries:
<<>>=
colMeans(BananaM(MCMC4$pars))    # was:c(0,0)
sd(BananaM(MCMC4$pars))          # was:1
cor(BananaM(MCMC4$pars))         # 0.9 off-diagonal
@

\section{Fitting a Monod function}
Example as in Berthoux and Brown, 2002.

<<>>=
require(FME)
@
 1. the observations
<<>>=
Obs <- data.frame(x=c(   28,  55,   83,  110,  138,  225,  375),   # mg COD/l
                  y=c(0.053,0.06,0.112,0.105,0.099,0.122,0.125))   # 1/hour
@
 2. the Monod model
<<>>=
Model <- function(p,x)   return(data.frame(x=x,y=p[1]*x/(x+p[2])))
@
3. Fitting the model to the data

First define the residual function
<<>>=
Residuals  <- function(p) (Obs$y-Model(p,Obs$x)$y)  #... model residuals
@
and fit the model to data
<<>>=
print(system.time(
P      <- modFit(f=Residuals,p=c(0.1,1))
))
@
Summary of fit
<<>>=
sP    <- summary(P)
sP[]
print(sP)
@
 plot best-fit model
<<>>=
x      <-0:375
@
<<label=Monplot, include=FALSE>>=
plot(Obs,pch=16,cex=2,xlim=c(0,400),ylim=c(0,0.15),
     xlab="mg COD/l",ylab="1/hr")
lines(Model(P$par,x))
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=Monplot,fig=TRUE,echo=FALSE>>=
<<Monplot>>
@
\end{center}
\caption{The Monod function - see text for \R-code}
\label{fig:Monod}
\end{figure}

 4. Run an MCMC analysis

Use an estimate of parameter covariances (to update parameters) and the model variance
<<>>=
Covar   <- sP$cov.scaled * 2.4^2/2
s2prior <- sP$modVariance

print(system.time(
MCMC <- modMCMC(f=Residuals,p=P$par,jump=Covar,niter=3000,
                var0=s2prior,wvar0=1,updatecov=100,lower=c(0,0))
))
cor(MCMC$pars)
cov(MCMC$pars)
sP$cov.scaled
@
Plot the results
<<label=Monmcmc, include=FALSE>>=
plot(MCMC,Full=TRUE)
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=Monmcmc,fig=TRUE,echo=FALSE>>=
<<Monmcmc>>
@
\end{center}
\caption{The mcmc - see text for \R-code}
\label{fig:Monmcm}
\end{figure}
a pairs plot
<<label=Monpairs, include=FALSE>>=
pairs(MCMC)
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=Monpairs,fig=TRUE,echo=FALSE>>=
<<Monpairs>>
@
\end{center}
\caption{Pairs plot - see text for \R-code}
\label{fig:Monmcmp}
\end{figure}

and the ranges
<<>>=
sR<-sensRange(parInput=MCMC$pars,func=Model,x=1:375)
@
<<label=Monsum, include=FALSE>>=
plot(summary(sR))
points(Obs)
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=Monsum,fig=TRUE,echo=FALSE>>=
<<Monsum>>
@
\end{center}
\caption{Pairs plot - see text for \R-code}
\label{fig:Monsum}
\end{figure}

<<label=Monhist, include=FALSE>>=
hist(MCMC,Full=TRUE,col="darkblue")
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=Monhist,fig=TRUE,echo=FALSE>>=
<<Monhist>>
@
\end{center}
\caption{Hist plot - see text for \R-code}
\label{fig:Monsum}
\end{figure}


Increase acceptance rate with delayed rejection
<<>>=
print(system.time(
MCMC2 <- modMCMC(f=Residuals,p=P$par,jump=Covar,niter=3000, ntrydr=3,
                var0=s2prior,wvar0=1,updatecov=100,lower=c(0,0))
))
MCMC2$count
@

show only the posterior model error and the function value
<<label=Monhist2, include=FALSE>>=
hist (MCMC,Full=TRUE,what=NULL,col="darkgreen")
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=Monhist2,fig=TRUE,echo=FALSE>>=
<<Monhist2>>
@
\end{center}
\caption{Hist plot 2 - see text for \R-code}
\label{fig:Monsum2}
\end{figure}



\section{Oxygen in the sediment}
\subsection{the model}
This is a simple model of oxygen, diffusing along a spatial gradient,
with imposed upper and lower boundary concentration
oxygen is consumed at maximal fixed rate, monod limitation

<<>>=
par(mfrow=c(2,2))
require(FME)
@
First the model parameters are defined...

<<>>=
pars <- c(upO2=360,  # concentration at upper boundary, mmolO2/m3
          lowO2=10,  # concentration at lower boundary, mmolO2/m3
          cons=80,   # consumption rate, mmolO2/m3/day
          ks=1)      # O2 half-saturation ct, mmolO2/m3
@
Next the sediment is vertically subdivided into 100 grid points
<<>>=
n  <- 100                       # nr grid points
dx <- 0.05   #cm
dX <- c(dx/2,rep(dx,n-1),dx/2)  # dispersion distances; half the grid size near boundaries
X  <- seq(dx/2,len=n,by=dx)     # distance from upper interface at middle of box
@
The model definition
<<>>=
O2fun <- function(pars)
{
  derivs<-function(t,O2,pars)
  {
  with (as.list(pars),{

    Flux <- -diff(c(upO2,O2,lowO2))/dX
    dO2  <- -diff(Flux)/dx-cons*O2/(O2+ks)

    return(list(dO2,UpFlux = Flux[1],LowFlux = Flux[n+1]))
  })
 }

 # Solve the steady-state conditions of the model
 ox <- steady.band(y=runif(n),func=derivs,parms=pars,nspec=1,positive=TRUE)
 data.frame(X=X,O2=ox$y)
}
@
The model is run
<<>>=
ox<-O2fun(pars)
@
and the results plotted...
<<>>=

<<label=O2plot, include=FALSE>>=
plot(ox$O2,ox$X,ylim=rev(range(X)),xlab="mmol/m3",
     main="Oxygen", ylab="depth, cm",type="l",lwd=2)
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=O2plot,fig=TRUE,echo=FALSE>>=
<<O2plot>>
@
\end{center}
\caption{The modeled oxygen profile - see text for \R-code}
\label{fig:o2}
\end{figure}

\subsection{Global sensitivity analysis : Sensitivity ranges}

1. First the sensitivity parameter range is set for the consumption rate

<<>>=
pRange <- data.frame (min=60,max=100)
rownames(pRange) <- "cons"
pRange
@
 2. Then sensitivity ranges for O2 are calculated.
The model is solved 100 times, according to a normal distribution, with
mean = 80, variance=100
<<>>=
print(system.time(
Sens2 <- sensRange(parms=pars,func=O2fun,dist="norm",
           num=100,parMean=c(cons=80),parCovar=100)
))
@
 3. The results are plotted
<<label=sens, include=FALSE>>=
plot(summary(Sens2),xyswap=TRUE,xlab= "O2",
     ylab="depth, cm",main="Sensitivity O2 model")
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=sens,fig=TRUE,echo=FALSE>>=
<<sens>>
@
\end{center}
\caption{Summary sensitivity plot - see text for \R-code}
\label{fig:mcmccum}
\end{figure}

\subsection{Local sensitivity analysis : Sensitivity functions}

The sensitivity functions are calculated
<<>>=
O2sens <- sensFun(func=O2fun,parms=pars)
@
Univariate sensitivity: summary of the sensitivity functions
<<>>=
summary(O2sens)
@
Bivariate sensitivity: the pair-wise relationship and the correlation
<<label=pairs, include=FALSE>>=
pairs(O2sens)
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=pairs,fig=TRUE,echo=FALSE>>=
<<pairs>>
@
\end{center}
\caption{pairs plot - see text for \R-code}
\label{fig:pairs}
\end{figure}

<<>>=
cor(O2sens[,-(1:2)])
@

Multivariate sensitivity is done by estimating the collinearity
<<>>=
Coll <- collin(O2sens)
Coll
@
<<label=coll, include=FALSE>>=
plot(Coll,log="y")
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=coll,fig=TRUE,echo=FALSE>>=
<<coll>>
@
\end{center}
\caption{collinearity - see text for \R-code}
\label{fig:coll}
\end{figure}

\subsection{Fitting the model to the data}
First define a function that returns only the required model output.
<<>>=
O2fun2 <- function(pars)
{
  derivs<-function(t,O2,pars)
  {
  with (as.list(pars),{

    Flux <- -diff(c(upO2,O2,lowO2))/dX
    dO2  <- -diff(Flux)/dx-cons*O2/(O2+ks)

    return(list(dO2,UpFlux = Flux[1],LowFlux = Flux[n+1]))
    })
  }

 # Solve the steady-state conditions of the model
 ox <- steady.band(y=runif(n),func=derivs,parms=pars,nspec=1,positive=TRUE)
 # return both the oxygen profile AND the fluxes at both ends
 list(data.frame(x=X,O2=ox$y),UpFlux=ox$UpFlux,LowFlux=ox$LowFlux)
}
@

This are the data
<<>>=
O2dat <- data.frame(x=seq(0.1,3.5,by=0.1),
    y = c(279,260,256,220,200,203,189,179,165,140,138,127,116,
          109,92,87,78,72,62,55,49,43,35,32,27,20,15,15,10,8,5,3,2,1,0))
O2depth <- cbind(name="O2",O2dat)        # oxygen versus depth
O2flux  <- c(UpFlux=170,LowFlux=0)       # measured fluxes
@
The Objective function to minimise; all parameters are fitted
<<>>=
Objective <- function (x)
{
 pars[]<- x

 # Solve the steady-state conditions of the model
 modO2 <- O2fun2(pars)

 # Model cost: first the oxygen profile
 Cost  <- modCost(obs=O2depth,model=modO2[[1]],x="x",y="y")

 # then the fluxes
 modFl <- c(UpFlux=modO2$UpFlux,LowFlux=modO2$LowFlux)
 Cost  <- modCost(obs=O2flux,model=modFl,x=NULL,cost=Cost)

 return(Cost)
}
@

We first estimate the collinearity of the parameters
<<>>=
print(system.time(
sF<-sensFun(Objective,parms=c(upO2=360,lowO2=10,cons=80,ks=1))
))
collin(sF)
@
The value of the full set is small enough.

Fit the parameters; constrained to be > 0
<<>>=
print(system.time(
Fit<-modFit(p=c(upO2=360,lowO2=10,cons=80,ks=1),
                  f=Objective,lower=c(0,0,0,0))
                  ))
Fit
(SFit<-summary(Fit))
@
Plot the residuals
<<label=res, include=FALSE>>=
plot(Objective(Fit$par),xlab="depth",ylab="",main="residual",legpos="top")
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=res,fig=TRUE,echo=FALSE>>=
<<res>>
@
\end{center}
\caption{residuals - see text for \R-code}
\label{fig:res}
\end{figure}

and show best-fit model
<<>>=
modO2 <- O2fun(Fit$par)
@
<<label=fit, include=FALSE>>=
plot(O2depth$y,O2depth$x,ylim=rev(range(O2depth$x)),pch=18,
     main="Oxygen-fitted", xlab="mmol/m3",ylab="depth, cm")
lines(modO2$O2,modO2$X)
@
\setkeys{Gin}{width=0.4\textwidth}
\begin{figure}
\begin{center}
<<label=fit,fig=TRUE,echo=FALSE>>=
<<fit>>
@
\end{center}
\caption{Best fit model - see text for \R-code}
\label{fig:fit}
\end{figure}

\subsection{Run MCMC}

Use parameter covariances of previous fit to update parameters
<<>>=
Covar   <- SFit$cov.scaled * 2.4^2/4
@
Set the mean variance of fit = prior for model variance
<<>>=
s2prior <- SFit$modVariance
@
Run an adaptive metropolis
<<>>=
print(system.time(
MCMC <- modMCMC(f=Objective,p=Fit$par,jump=Covar,niter=500,ntrydr=2,
                var0=s2prior,wvar0=1,updatecov=100,lower=c(NA,0,NA,0))
))
MCMC$count
@

Plot the results
<<label=mcmcplot, include=FALSE>>=
plot(MCMC,Full=TRUE)
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=mcmcplot,fig=TRUE,echo=FALSE>>=
<<mcmcplot>>
@
\end{center}
\caption{MCMC plot results - see text for \R-code}
\label{fig:mcmcp}
\end{figure}

<<label=mcmchist, include=FALSE>>=
hist(MCMC,Full=TRUE)
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=mcmchist,fig=TRUE,echo=FALSE>>=
<<mcmchist>>
@
\end{center}
\caption{MCMC histogram results - see text for \R-code}
\label{fig:mcmch}
\end{figure}

<<label=mcmcpairs, include=FALSE>>=
pairs(MCMC,Full=TRUE)
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=mcmcpairs,fig=TRUE,echo=FALSE>>=
<<mcmcpairs>>
@
\end{center}
\caption{MCMC pairs plot - see text for \R-code}
\label{fig:mcmcp}
\end{figure}
or summaries can be created:
<<>>=
summary(MCMC)
cor(MCMC$pars)
@
<<label=mcmcrange, include=FALSE>>=
plot(summary(sensRange(parInput=MCMC$par,f=O2fun,num=500)),xyswap=TRUE)
points(O2depth$y,O2depth$x)
@
\setkeys{Gin}{width=0.8\textwidth}
\begin{figure}
\begin{center}
<<label=mcmcrange,fig=TRUE,echo=FALSE>>=
<<mcmcrange>>
@
\end{center}
\caption{MCMC range plot - see text for \R-code}
\label{fig:mcmcr}
\end{figure}


\bibliography{vignettes}

\end{document}
